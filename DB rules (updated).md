FECRO / HUBGATE – Backend Database Architecture (Clean 2025 Edition)


Covers: Schema, RLS, Views, Functions, Events, Worker Model, Contact Privacy, Quotations, RFQs, Companies

⸻

——————————

0. PURPOSE OF THIS DOCUMENT

——————————

This document defines the database backend contract for the Fecro/HubGate platform.

It is written for:
	•	Supabase backend engineers
	•	Worker/API developers
	•	Frontend engineers consuming RFQs/Quotations
	•	Security reviewers
	•	Future maintainers

This is the authoritative description of:
	1.	Schema layout
	2.	RLS (Row Level Security) — FINAL version
	3.	Views — using SECURITY INVOKER only
	4.	Triggers & functions
	5.	Event logs
	6.	Worker-mediated security model
	7.	Quotation interest + Contact unlock system (2025 v3)
	8.	Seller RFQ Hydration workflow
	9.	Company isolation rules

Everything here reflects the final working implementation as fixed in this chat.

⸻

==========================================

1. DATABASE OVERVIEW — HIGH LEVEL

==========================================

The marketplace backend has four main domains:
	1.	Companies & Memberships
	2.	RFQs (Requests for Quotation)
	3.	Quotations & Contact Unlock System
	4.	Categories & Taxonomy

Security rule:
Sellers NEVER read RFQs directly from Supabase.
All seller reading is done via Cloudflare Worker under service_role with strict company isolation.

⸻

==========================================

2. COMPANIES & MEMBERSHIPS

==========================================

A user cannot interact with the platform until they belong to a company.

2.1 Tables

companies
	•	id uuid pk
	•	name text unique (lowercase)
	•	phone text
	•	city, state, country
	•	created_at timestamptz

Used for contact unlock system.

company_memberships

Connects users to companies.

Fields:
	•	id uuid pk
	•	company_id uuid fk
	•	user_id uuid fk -> auth.users
	•	track ('procurement' | 'sales')
	•	role_level int
	•	30 = manager
	•	10 = member
	•	created_at, updated_at

Unique:
	•	(company_id, user_id)

company_invites

Used to invite users.

⸻

2.2 RLS

company_memberships

SELECT: user_id = auth.uid()
INSERT/UPDATE/DELETE: service_role only

companies

SELECT: allowed through Worker or invoker views
INSERT/UPDATE/DELETE: service_role only

Why?
Contact visibility uses this information, but the UI does NOT directly fetch membership rows — Worker or views handle it.

⸻

==========================================

3. RFQs — NORMALIZED STRUCTURE

==========================================

An RFQ has:
	1.	Header → rfqs
	2.	Items → rfq_items
	3.	Specs → rfq_item_specs

Everything normalized for searching & indexing.

⸻

3.1 Table: rfqs

Core fields:
	•	id uuid pk
	•	public_id text (buyer-facing RFQ ID)
	•	seller_rfq_id text unique (auto-generated)
	•	user_id uuid (owner)
	•	buyer_company_id uuid (company posting)
	•	status text
	•	posted_time timestamptz
	•	incoterms, payment, delivery_time
	•	quotations int
	•	views int
	•	created_at, updated_at

Seller RFQ ID

Generated by trigger:

Function: rfq_set_seller_rfq_id()
Trigger: trg_rfqs_set_seller_rfq_id

Format example:

SRF-C4E104013E

Unique & indexed.

⸻

3.2 Table: rfq_items
	•	id uuid pk
	•	rfq_id uuid fk
	•	product_name
	•	quantity numeric
	•	purchase_type
	•	category_path text (optional)
	•	created_at, updated_at

⸻

3.3 Table: rfq_item_specs

Specs are normalized into rows:
	•	id uuid pk
	•	rfq_item_id
	•	key_norm
	•	key_label
	•	value
	•	unit
	•	Unique (rfq_item_id, key_norm)

⸻

3.4 RPC: Upsert Items & Specs

Function:

rfq_upsert_items_and_specs(_rfq_id uuid, _items jsonb)

Used by both createRFQ & updateRFQ.

Atomic → inserts + updates items/specs.

⸻

3.5 RLS for RFQs & Items

Buyers:

SELECT: rfqs.user_id = auth.uid()
INSERT: user_id = auth.uid()
UPDATE/DELETE: user_id = auth.uid()

Sellers:

No direct Supabase access for RFQs — must use Worker.

⸻

============================================================

4. SELLER HYDRATION — CORE SECURITY PRINCIPLE

============================================================

Sellers CANNOT see RFQs directly.
Instead they call Worker:

Workflow:
	1.	Worker validates JWT
	2.	Worker loads seller company via company_memberships
	3.	Worker enforces:

rfqs.status = 'active'
AND rfqs.buyer_company_id != seller_company_id

	4.	Worker calls secure function:

rfq_hydrate_seller(_rfq_id, _seller_id)

Function is SECURITY DEFINER but callable only through Worker (PUBLIC revoked).

Returns a JSON RFQ safe for sellers.

⸻

==========================================

5. QUOTATIONS — CORE STRUCTURE

==========================================

Quotations have:
	•	quotations table (header)
	•	quotation_items
	•	quotation_item_specs

⸻

5.1 Table: quotations

Fields:
	•	id uuid pk
	•	rfq_id
	•	seller_id (= auth.uid())
	•	seller_company_id
	•	created_by_membership_id
	•	currency text
	•	total_price numeric
	•	delivery_timeline_days
	•	payment_terms
	•	shipping_terms
	•	notes
	•	seller_quote_ref
	•	internal_reference
	•	status
(draft | submitted | accepted | rejected | withdrawn | expired)
	•	submitted_at
	•	expires_at
	•	contacts_unlocked boolean
	•	created_at, updated_at

RLS:

Seller: SELECT/INSERT/UPDATE/DELETE where seller_id = auth.uid()
Buyer: SELECT where rfqs.user_id = auth.uid()


⸻

5.2 Table: quotation_interest

The contact unlock system (v3).

Fields:
	•	id uuid pk
	•	rfq_id
	•	quotation_id
	•	buyer_id
	•	buyer_company_id
	•	seller_id
	•	seller_company_id
	•	status ('pending' | 'approved' | 'rejected')
	•	resolution_note
	•	created_at, updated_at, resolved_at

RLS:

Buyers see rows where:

buyer_id = auth.uid()

Sellers see rows where:

seller_id = auth.uid()

No cross-visibility.

⸻

5.3 Contact Unlock Logic (Final 2025)

Buyer clicks: “I’m interested”

Creates a row in quotation_interest:

status = 'pending'

Seller sees request → Approve or Reject

If approved:
	1.	quotation.contacts_unlocked = true
	2.	Buyer & seller both gain access to the other company’s contact profile.

Company contact info comes from:

companies
company_memberships

User personal info (email/phone) intentionally NOT exposed yet.

⸻

==========================================

6. CONTACT FETCH V3 (SECURE & CORRECT)

==========================================

The latest implementation (after debugging):

For Buyer → fetchSellerContactForQuotation:

Returns:

company_name
company_phone
city
state
country

Retrieved via:

company_memberships → companies
WHERE user_id = quotation.seller_id

For Seller → fetchBuyerContactForQuotation:

Same pattern, using buyer_id.

RLS fix:

We do not select membership rows directly, we select only through views or Worker.

⸻

==========================================

7. VIEWS — FINAL SECURITY FORMAT

==========================================

All app-facing views MUST be:

CREATE VIEW ... SECURITY INVOKER;

Updated in this chat:

7.1 v_rfqs_card

Old: SECURITY DEFINER → ❌
New: SECURITY INVOKER → ✅

Definition:

SELECT r.id,
       r.public_id,
       r.seller_rfq_id,
       r.title,
       r.status,
       r.posted_time,
       r.quotations,
       r.views,
       c.name AS company_name
FROM rfqs r
JOIN companies c ON c.id = r.buyer_company_id;

7.2 v_quotation_interest_summary

Old: SECURITY DEFINER → ❌
New: SECURITY INVOKER → ✅

SELECT quotation_id,
       count(*) FILTER (WHERE status='pending')  AS pending_count,
       count(*) FILTER (WHERE status='approved') AS approved_count,
       count(*) FILTER (WHERE status='rejected') AS rejected_count
FROM quotation_interest
GROUP BY quotation_id;

All PUBLIC privileges revoked.

⸻

==========================================

8. AUDIT & EVENT LOGS

==========================================

All logs are append-only and service_role-only.

8.1 Tables:
	•	user_role_audit_log
	•	company_membership_audit_log
	•	rfq_event_log
	•	quotation_event_log

8.2 Behavior:

Each has a trigger capturing:
	•	action
	•	old_row/new_row
	•	timestamps
	•	user id (where relevant)

Used for dispute resolution & debugging.

⸻

==========================================

9. WORKER SECURITY MODEL

==========================================

The Cloudflare Worker is the gatekeeper.

Worker responsibilities:
	•	Validate JWT
	•	Determine user company
	•	Filter RFQs by company isolation
	•	Call SECURITY DEFINER functions with service_key
	•	Prevent sellers from accessing buyer-only data
	•	Prevent buyers from accessing seller-only logs
	•	Perform write operations for companies & memberships
	•	Hide sensitive columns not meant for UI

The Worker is the ONLY path that bypasses RLS (via service_role).

⸻

==========================================

10. MIGRATIONS

==========================================

Recent migrations done in this chat:

✔ SECURITY INVOKER Fix Migration

20251208_142233_fix_views_security_invoker.sql

Actions:
	•	Drop & recreate v_rfqs_card as SECURITY INVOKER
	•	Drop & recreate v_quotation_interest_summary as SECURITY INVOKER
	•	Revoke public privileges

✔ Seller RFQ ID migration

✔ Contact unlock system updates

✔ Quotation interest logic updates

✔ Company membership RLS fix

✔ Debug removal + UI sync updates

⸻

==========================================

11. FUTURE TODO (ALREADY IDENTIFIED)

==========================================

To complete the backend:

❗ Add a DB-level “Quotation expiration” cron

❗ Add a DB-level “auto-close RFQ after accepted quote”

❗ Add full audit for quotation_interest

❗ Add primary membership for multi-company users

❗ Convert RFQ card query into a Worker endpoint

⸻

==========================================

12. END OF DOCUMENT

==========================================

