HubGate — Database Architecture & Security Rules

Full Backend Specification — Updated 2025-12-08

This document defines the complete structure, rules, flows, triggers, RLS, views, and security constraints of the HubGate backend.

It replaces all older documentation.

⸻

TABLE OF CONTENTS
	1.	Architecture Overview
	2.	Companies & Memberships
	3.	RFQs
	4.	RFQ Items & Specs
	5.	Quotations
	6.	Quotation Interest (Buyer ↔ Seller Contact Unlock)
	7.	Views (SECURITY INVOKER)
	8.	RLS (Row Level Security)
	9.	Audit & Event Logging
	10.	RPC Functions
	11.	Triggers
	12.	Workers (Cloudflare) — Access Rules
	13.	Security Model
	14.	Testing RLS
	15.	Appendix: Migration Index

⸻

———————————––

1. ARCHITECTURE OVERVIEW

———————————––

HubGate uses a strongly normalized Postgres architecture:

Layer	Purpose
Supabase Auth	Users & JWT
public.companies	Company registry
public.company_memberships	Connect users ↔ company
public.rfqs	RFQ headers
public.rfq_items	Line items of RFQ
public.rfq_item_specs	Specs of items
public.quotations	Seller quotations
public.quotation_items	Quotation item-level data
public.quotation_item_specs	Quotation spec overrides
public.quotation_interest	Buyer requests seller contact
Views	SEC_INV + RLS for efficient reads
Cloudflare Worker	Enforces company isolation & seller flow

All write-sensitive actions (company creation, invites, category imports, seller hydrate) go through Cloudflare Worker with service role key.

⸻

———————————––

2. COMPANIES & MEMBERSHIPS

———————————––

2.1 companies

id UUID PK
name TEXT UNIQUE (lowercase)
created_at timestamptz
phone TEXT nullable
city TEXT nullable
state TEXT nullable
country TEXT nullable

Purpose
	•	Every user must belong to a company.
	•	All buyer/seller visibility rules depend on this.

⸻

2.2 company_memberships

id UUID PK
company_id FK → companies.id
user_id FK → auth.users.id
track TEXT ('procurement' | 'sales')
role_level INT (10 member, 30 manager)
created_at timestamptz
updated_at timestamptz

Purpose
	•	Defines user role inside company.
	•	Worker uses this to determine buyer_company_id or seller_company_id for all operations.

⸻

2.3 company_invites

Tracks invitations for adding teammates.

⸻

———————————––

3. RFQs

———————————––

rfqs table

id UUID PK
public_id TEXT               (RFQ-xxxxx)
seller_rfq_id TEXT UNIQUE    (SRF-xxxxxxxxxx)
title TEXT
description TEXT
user_id FK → auth.users
buyer_company_id FK → companies.id
posted_time timestamptz
created_at timestamptz
updated_at timestamptz
status TEXT ('active','closed')
quotations INT
views INT
delivery_time TEXT
payment TEXT
incoterms TEXT

Auto-generated seller RFQ ID

Trigger: trg_rfqs_set_seller_rfq_id
Function: rfq_set_seller_rfq_id()

⸻

———————————––

4. RFQ ITEMS & SPECS

———————————––

rfq_items

id UUID PK
rfq_id FK
product_name TEXT
quantity NUMERIC
purchase_type TEXT
barcode TEXT
created_at, updated_at

rfq_item_specs

id UUID PK
rfq_item_id FK
key_norm TEXT
key_label TEXT
value TEXT
unit TEXT
UNIQUE (rfq_item_id, key_norm)

RPC:

rfq_upsert_items_and_specs(rfq_id, items_jsonb)
Used for atomic RFQ creation & updates.

⸻

———————————––

5. QUOTATIONS

———————————––

quotations

id UUID PK
rfq_id UUID FK
seller_id UUID FK → auth.users
seller_company_id UUID FK → companies
created_by_membership_id FK → company_memberships

status TEXT  (draft/submitted/accepted/rejected/expired)
submitted_at timestamptz
expires_at timestamptz
contacts_unlocked BOOLEAN

total_price NUMERIC
currency TEXT
payment_terms TEXT
shipping_terms TEXT
delivery_timeline_days INT
validity_days INT
notes TEXT
seller_quote_ref TEXT
buyer_quote_ref TEXT
internal_reference TEXT
seller_company TEXT

line_items JSONB (temporary storage)
created_at, updated_at

quotation_items

Per-item structured storage.

quotation_item_specs

Overrides of buyer specs.

⸻

———————————––

6. QUOTATION INTEREST

———————————––

This powers the seller–buyer contact unlock workflow.

quotation_interest

id UUID PK
rfq_id UUID
quotation_id UUID
buyer_id UUID
buyer_company_id UUID
seller_id UUID
seller_company_id UUID
status TEXT ('pending','approved','rejected')
resolution_note TEXT
resolved_at timestamptz
created_at timestamptz
updated_at timestamptz

Flow
	1.	Buyer presses “I’m interested”
	2.	Row inserted → status = pending
	3.	Seller approves/rejects
	4.	If approved:
	•	quotation.contacts_unlocked = true
	•	Buyer sees seller contact
	•	Seller sees buyer contact

⸻

———————————––

7. VIEWS (SECURITY INVOKER)

———————————––

7.1 v_rfqs_card (FIXED 2025-12-08)

Final view definition:

CREATE OR REPLACE VIEW public.v_rfqs_card AS
SELECT
  r.id,
  r.public_id,
  r.seller_rfq_id,
  r.user_id AS buyer_id,
  r.buyer_company_id,
  r.title,
  r.status,
  r.created_at,
  r.posted_time,
  r.quotations,
  r.views,

  /* category path last-level */
  (SELECT c2.name
   FROM categories c2
   WHERE c2.id = r.category_id) AS first_category_path,

  /* count items */
  (SELECT COUNT(*) FROM rfq_items i WHERE i.rfq_id = r.id) AS items_count,

  /* company fields */
  c.city AS company_city,
  c.state AS company_state,
  c.country AS company_country,
  c.name AS company_name

FROM public.rfqs r
JOIN public.companies c
  ON c.id = r.buyer_company_id;

ALTER VIEW public.v_rfqs_card SET (security_invoker = on);
GRANT SELECT ON public.v_rfqs_card TO authenticated;


⸻

7.2 v_quotation_interest_summary (FIXED)

CREATE OR REPLACE VIEW public.v_quotation_interest_summary AS
SELECT
  quotation_id,
  COUNT(*) FILTER (WHERE status = 'pending') AS pending_count,
  COUNT(*) FILTER (WHERE status = 'approved') AS approved_count,
  COUNT(*) FILTER (WHERE status = 'rejected') AS rejected_count
FROM public.quotation_interest
GROUP BY quotation_id;

ALTER VIEW public.v_quotation_interest_summary SET (security_invoker = on);
GRANT SELECT ON public.v_quotation_interest_summary TO authenticated;


⸻

———————————––

8. RLS (ROW LEVEL SECURITY)

———————————––

rfqs
	•	Buyer: can SELECT/UPDATE/DELETE only rows where user_id = auth.uid()
	•	Sellers: never see RFQs directly → Worker enforces company isolation

quotations

Sellers

seller_id = auth.uid()

Buyers

Can view a quotation if:

rfqs.user_id = auth.uid()

quotation_items / quotation_item_specs

Inherit RLS via parent quotation.

quotation_interest

Buyer sees only his rows.
Seller sees only interest rows where:

seller_id = auth.uid()

companies & memberships
	•	SELECT: minimal; used by Worker via service key
	•	INSERT/UPDATE: service role only

⸻

———————————––

9. AUDIT & EVENT LOGS

———————————––

user_role_audit_log

Trigger on auth.users

company_membership_audit_log

Trigger on company_memberships

rfq_event_log

Trigger on rfqs

quotation_event_log

Trigger on quotations

All are append-only with service role RLS only.

⸻

———————————––

10. RPC FUNCTIONS

———————————––

rfq_upsert_items_and_specs

Atomic RFQ update.

rfq_hydrate_seller

SECURITY DEFINER, but Worker ensures:

rfq.status = 'active'
rfq.buyer_company_id != seller_company_id

Prevents leaking buyer data to same-company sellers.

⸻

———————————––

11. TRIGGERS

———————————––

seller_rfq_id generator

trg_rfqs_set_seller_rfq_id

updated_at triggers for all major tables

audit logs triggers

⸻

———————————––

12. WORKER (CLOUDFLARE) — ACCESS RULES

———————————––

Worker enforces:

Seller browsing RFQs:

status = 'active'
buyer_company_id != seller_company_id

RFQ hydration:

Worker must ensure checks before calling RPC.

Company creation/invites:

Worker uses service role to bypass RLS.

⸻

———————————––

13. SECURITY MODEL

———————————––

Principles:
	1.	Frontend never has service role key
	2.	Sellers do NOT query Supabase directly for RFQs
	3.	Views use SECURITY INVOKER
	4.	RLS enforced everywhere
	5.	All company writes go through Worker

⸻

———————————––

14. TESTING RLS

———————————––

Set JWT:

SELECT set_config(
 'request.jwt.claims',
 json_build_object('role','authenticated','sub','USER_ID')::text,
 true
);

Test:

SELECT * FROM rfqs;
SELECT * FROM v_rfqs_card;
SELECT * FROM quotations;
SELECT * FROM quotation_interest;



⸻

14.1 DEBUG: INSPECT USER + COMPANY LINKAGE

Use this canonical query to inspect what the backend “thinks” about a given user and their company.  
This combines `auth.users`, `company_memberships`, and `companies` in one view and is useful to compare against the `/me` worker response and quotation flows.

```sql
-- Replace with the target user id or email
select
  u.id                              as user_id,
  u.email,
  u.raw_user_meta_data              as user_metadata,
  cm.company_id,
  cm.track,
  cm.role_level,
  cm.is_manager,
  c.name                            as company_name,
  c.phone,
  c.city,
  c.state,
  c.country
from auth.users u
left join public.company_memberships cm
  on cm.user_id = u.id
left join public.companies c
  on c.id = cm.company_id
where u.id = '5fe5624a-8fb1-43e2-9f1c-08818457fa73';
-- or:
-- where u.email = '1@1.com';
```

⸻

———————————––

15. MIGRATION INDEX

———————————––

2025-12-08

✔ Fix v_rfqs_card to include all fields used by API
✔ Security Invoker migration
✔ Fix v_quotation_interest_summary
✔ Contact unlock stable

2025-11

✔ Added companies + memberships + invites
✔ Added quotation_interest
✔ Seller RFQ hydration
✔ seller_rfq_id generator

2025-10

✔ Spec normalization
✔ RPC rebuild
✔ Category engine improvements

⸻

END OF FILE

DB Rules 2025-12-08.md
